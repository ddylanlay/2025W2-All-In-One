import { useEffect } from 'react';
import { useAppDispatch } from '/app/client/store';
import { setNotificationConversations, setUnreadMessageCount, fetchNotificationTasks } from '../state/notification-slice';
import { useMessagingSubscriptions } from '../../role-messages/hooks/useMessagingSubscriptions';
import { useAppSelector } from '/app/client/store';
import { selectActiveConversationId } from '../../role-messages/state/reducers/messages-slice';
import { formatConversationTimestamp } from '../../role-messages/utils/timestamp-utils';

interface UseNotificationSubscriptionsProps {
  enabled?: boolean;
}

/**
 * Hook that integrates messaging subscriptions with the notification system
 * This ensures the notification bell gets real-time updates when new messages arrive
 */
export function useNotificationSubscriptions({ enabled = true }: UseNotificationSubscriptionsProps = {}) {
  const dispatch = useAppDispatch();

  // Get current user info for determining message ownership
  const currentUser = useAppSelector((state) => state.currentUser.currentUser);
  const authUser = useAppSelector((state) => state.currentUser.authUser);
  const activeConversationId = useAppSelector(selectActiveConversationId);

  // Use the existing messaging subscriptions hook
  const { conversationsReady, messagesReady, conversations } = useMessagingSubscriptions(activeConversationId);

  // Update notification slice when conversations change
  useEffect(() => {
    if (!enabled || !conversationsReady || conversations.length === 0) {
      return;
    }

    // Determine current user ID for unread count calculation
    let currentUserId: string | undefined;

    if (authUser && currentUser) {
      if (authUser.role === 'agent' && 'agentId' in currentUser) {
        currentUserId = currentUser.agentId;
      } else if (authUser.role === 'tenant' && 'tenantId' in currentUser) {
        currentUserId = currentUser.tenantId;
      } else if (authUser.role === 'landlord' && 'landlordId' in currentUser) {
        currentUserId = currentUser.landlordId;
      }
    }

    if (currentUserId) {
      // Convert ConversationDocument[] to Conversation[] format for notifications
      const notificationConversations = conversations.map(conv => ({
        id: conv._id,
        name: conv.tenantId ? 'Tenant' : conv.agentId ? 'Agent' : conv.landlordId ? 'Landlord' : 'User',
        role: conv.tenantId ? "Tenant" : conv.agentId ? "Agent" : "User",
        avatar: '', // Will be generated by the slice if needed
        lastMessage: conv.lastMessage?.text || "No messages yet",
        timestamp: conv.lastMessage?.timestamp ?
          formatConversationTimestamp(new Date(conv.lastMessage.timestamp)) : '',
        unreadCount: conv.unreadCounts?.[currentUserId] || 0,
      }));

      // Update conversations in notification slice
      dispatch(setNotificationConversations(notificationConversations));

      // Calculate and update total unread count
      const totalUnreadCount = notificationConversations.reduce((sum, conv) => sum + (conv.unreadCount || 0), 0);
      dispatch(setUnreadMessageCount(totalUnreadCount));
    }
  }, [conversations, conversationsReady, enabled, dispatch, currentUser, authUser]);

  return {
    conversationsReady,
    messagesReady,
    isEnabled: enabled
  };
}
